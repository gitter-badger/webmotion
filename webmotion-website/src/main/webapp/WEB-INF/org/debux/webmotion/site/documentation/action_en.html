<!--
  #%L
  Webmotion website
  
  $Id$
  $HeadURL$
  %%
  Copyright (C) 2011 Debux
  %%
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as 
  published by the Free Software Foundation, either version 3 of the 
  License, or (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Lesser Public License for more details.
  
  You should have received a copy of the GNU General Lesser Public 
  License along with this program.  If not, see
  <http://www.gnu.org/licenses/lgpl-3.0.html>.
  #L%
  -->
<div id="article">

<h1>Java action</h1>

<script type="text/javascript" src="../lib/generated_toc.js"></script>
<div id="generated-toc" class="generate_from_h2 generate_for_article"></div>

<h2 class="page-header" id="controller">WebMotionController</h2>
<p>
    In WebMotion, if you decide that the treatment to perform for a given URL
    is to execute Java code, then the called method must be a method of a class
    inheriting <a href="http://projects.debux.org/project-site/webmotion/apidocs/org/debux/webmotion/server/WebMotionController.html">WebMotionController</a>.
    This class has the following features:
</p>

<ul>
    <li>possibility of returning a rendering (adding information in the HTTP response, such as a web page, a JSON stream, etc.) ;</li>
    <li>access to the web context (which gives access to the user session, the request, the response, etc.) ;</li>
    <li>possibility of creating &laquo;&nbsp;flash&nbsp;&raquo; messages to return messages to the user (time-sensitive messages) ;</li>
    <li>possibility of validating the parameters of the called method with annotations.</li>
</ul>

<pre class="prettyprint">
public class User extends WebMotionController {
    public Render find(String id) {
        ...
        return ...
    }
    ...
}
</pre>

<p>
    All the controllers in WebMotion are instantiated only once (singleton pattern).
    They are made to be used stateless, so it is strongly recommended not to create instance variables in the controllers,
    unless you are really sure of what you are doing!
</p>

<h2 class="page-header" id="render">Different kinds of rendering</h2>
<p>
    A rendering is the response returned to the client which made a request to the server.
    The renderings can be returned whether in a filter or in a controller.
</p>
<p>
    It frequently happens that a rendering is generated by using a linked model.
    <strong>The model is transmitted with a set of key/value pairs.</strong>
</p>

<h3>Page rendering: renderView</h3>
<p>
    The <code>renderView</code> method, called in a method of a WebMotionController,
    enables to return a resource (typically a web page, JSP, HTML, plain text) to the client.
    In this case, the model is passed as an attribute of the request (refer to the
    <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/ServletRequest.html#setAttribute(java.lang.String,%20java.lang.Object)">
        ServletRequest.setAttribute()
    </a> method).
</p>

<p>
    <span class="label label-info">Example</span> Returns a JSP page:
</p>
<pre class="prettyprint">
return renderView("index.jsp");
</pre>

<p>
    <span class="label label-info">Example</span> Returns a html page:
</p>
<pre class="prettyprint">
return renderView("index.html");
</pre>

<p>
    <span class="label label-info">Example</span> Returns a html page in the page directory:
</p>
<pre class="prettyprint">
return renderView("page/index.html");
</pre>

<p>
    <span class="label label-info">Example</span> Returns a JSP page with the model:
</p>
<pre class="prettyprint">
return renderView("index.jsp", "name", "value");
</pre>
<p>Avec la page JSP :</p>
<pre>
Value = ${name}
</pre>

<h3>HTTP redirection: renderURL or renderRedirect</h3>
<p>
    This kind of rendering enables to redirect the web client to another URL.
    It can be an absolute URL (eg an external domain) as well as a URL relative to the current path.
    By default, the URLs are relative to the extension. To call a path out of the extension,
    you need to specify <code>/deploy</code> at the begining of your URL.
</p>
<p>
    A HTTP redirection can be useful to redirect the user after the submission of a form.
    In this kind of rendering, the model is added to the parameters of the redirection URL.
</p>

<p>
    <span class="label label-info">Example</span> Relative URL:
</p>
<pre class="prettyprint">
return renderURL("/display");
// or
return renderRedirect("/display");
</pre>

<p>
    <span class="label label-info">Example</span> Absolute URL:
</p>
<pre class="prettyprint">
return renderURL("http://www.google.fr");
// or
return renderRedirect("http://www.google.fr");
</pre>

<p>
    <span class="label label-info">Example</span> Relative URL with a model:
</p>
<pre class="prettyprint">
// The user will be redirected to the /user?id=1232323&amp;action=view address
return renderURL("/user", "id", 1232323, "action", "view");
</pre>

<h3>Redirection to another controller: renderAction</h3>
<p>
    The redirection to another controller enables to link several actions
    and to return the rendering of the last contoller.
    In this case, the model passed in the parameters is directly in the parameters of the called controller.
</p>

<p>
    <span class="label label-info">Example</span> Direct call:
</p>
<pre class="prettyprint">
public class Call extends WebMotionController {
    public Render action() {
        // ...
        return next("test");
    }

    public Render next(String value) {
        // ...
    }
}
</pre>

<p>
    <span class="label label-info">Example</span> Indirect call:
</p>
<pre class="prettyprint">
public class Call extends WebMotionController {
    public Render action() {
        // ...
        return renderAction("Call.next", "test");
    }

    public Render next(String value) {
        // ...
    }
}
</pre>

<h3>Forward to another controller: renderForward</h3>
<p>
    The forward to another controller enables to link several actions
    and to return the rendering of the last controller by using the a URL in the mapping,
    without redirection at the client level.
    In this case, the model passed in the parameters is directly in the parameters of the called controller.
    By default, the URLs are relative to the extension. To call a path out of the extension,
    you need to specify <code>/deploy</code> at the begining of your URL.
</p>

<p>
    <span class="label label-info">Example</span> Call of an internal action via the URL:
</p>
<pre class="prettyprint">
return renderForward("/internal/action", "param", "internal");
</pre>

<p>
    With the following action:
</p>
<pre class="prettyprint">
public Render action(String param) {
    return ...
}
</pre>

<p>
    <span class="label label-info">Exemple</span> Call of an internal action via the URL with attributes:
</p>
<pre class="prettyprint">
return renderForward("/internal/action", new Object[]{"param", "internal"}, new Object[]{"att", "value"});
</pre>

<h3>Rendering of contents: renderContent</h3>
<p>
    The <code>renderContent</code> method enables to return
    directly the string which will be interpreted by the client as the specified MIME type.
</p>

<p>
    <span class="label label-info">Example</span> Direct HTML rendering:
</p>
<pre class="prettyprint">
// Displaysra "example" as an h1 title
return renderContent("&lt;h1&gt;example&lt;/h1&gt;", "text/html");
</pre>

<p>
    <span class="label label-info">Example</span> Direct plain text rendering:
</p>
<pre class="prettyprint">
// Displays "&lt;h1&gt;example&lt;/h1&gt;"
return renderContent("&lt;h1&gt;example&lt;/h1&gt;", "text/plain");
</pre>

<h3>Stream redering: renderStream</h3>
<p>
    The <code>renderContent</code> method
    enables to return directly a stream in the response, which will be interpreted
    as the specified MIME type.
</p>

<p>
    <span class="label label-info">Example</span> Returns a PDF document in the classpath:
</p>
<pre class="prettyprint">
ClassLoader classLoader = Stream.class.getClassLoader();
InputStream stream = classLoader.getResourceAsStream("doc.pdf");
return renderStream(stream, "application/pdf");
</pre>

<p>
    <span class="label label-info">Example</span> Returns an image in the classpath:
</p>
<pre class="prettyprint">
ClassLoader classLoader = Stream.class.getClassLoader();
InputStream stream = classLoader.getResourceAsStream("logo.png");
return renderStream(stream, "image/png");
</pre>

<h3>Rendering for download: renderDownload</h3>
<p>
    The <code>renderDownload</code> method
    enables to return the stream as an attachment in the response to provoke the downloading
    of the file by the browser.
</p>

<p>
    <span class="label label-info">Example</span> Returns a PDF document in the classpath:
</p>
<pre class="prettyprint">
ClassLoader classLoader = Stream.class.getClassLoader();
InputStream stream = classLoader.getResourceAsStream("doc.pdf");
return renderDownload(stream, "file.pdf", "application/pdf");
</pre>

<p>
    <span class="label label-info">Example</span> Returns an image in the classpath:
</p>
<pre class="prettyprint">
ClassLoader classLoader = Stream.class.getClassLoader();
InputStream stream = classLoader.getResourceAsStream("logo.png");
return renderDownload(stream, "image.pdf", "image/png");
</pre>

<h3>Page reloading: renderLastPage</h3>
<p>
    The <code>renderLastPage</code> method enables to refresh the current page.
    It uses the referer in the HTTP request header.
</p>

<p>
    <span class="label label-info">Example</span> Reload the page:
</p>
<pre class="prettyprint">
return renderLastPage();
</pre>

<p>
    <span class="label label-info">Example</span> Reload the page and pass additional parameters:
</p>
<pre class="prettyprint">
return renderLastPage("id", 122345);
</pre>

<h3>HTTP code return: renderStatus</h3>
<p>
    The <code>renderStatus</code> method enables to return a HTTP status code
    to the client. You can use the constants in the interface
    <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletResponse.html">
        HttpServletResponse
    </a>.
</p>

<p>
    <span class="label label-info">Example</span> Returns a HTTP code 200 as ping:
</p>
<pre class="prettyprint">
return renderStatus(HttpServletResponse.SC_OK);
</pre>

<p>
    <span class="label label-info">Example</span> Shortcut to return a HTTP code 200 to the user :
</p>
<pre class="prettyprint">
return renderSuccess();
</pre>

<h3>Error return: renderError</h3>
<p>
    The <code>renderError</code> method enables to return
    a HTTP error code to the client. You can use the constants in the interface
    <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletResponse.html">
        HttpServletResponse
    </a>.
</p>

<p>
    <span class="label label-info">Example</span> Returns a 404 error to the user:
</p>
<pre class="prettyprint">
return renderError(HttpServletResponse.SC_NOT_FOUND);
</pre>

<p>
    <span class="label label-info">Example</span> Returns a 404 error to the user with a message:
</p>
<pre class="prettyprint">
return renderError(HttpServletResponse.SC_NOT_FOUND, "Not found because ...");
</pre>

<p>
    <span class="label label-info">Example</span> Shortcut to return a 500 error to the user :
</p>
<pre class="prettyprint">
return renderFailure();
</pre>

<h3>XML stream rendering: renderXML</h3>
<p>
    The <code>renderXML</code> method enables to return the XML representation
    of the Java object in the parameters to the client.
    The XML serialization is performed thanks to the
    <a href="http://xstream.codehaus.org/">XStream</a> library.
</p>

<p>
    <span class="label label-info">Example</span> Returns an object as XML:
</p>
<pre class="prettyprint">
User user = new User("John", "Brown");
return renderXML(user);
</pre>

<p>
    <span class="label label-info">Example</span> Returns a map:
</p>
<pre class="prettyprint">
return renderXML("key", user);
</pre>

<h3>JSON stream rendering: renderJSON</h3>
<p>
    The <code>renderJSON</code> method enables to return the JSON representation
    of the Java object in the parameters to the client.
    The JSON serialization is performed thanks to the
    <a href="https://code.google.com/p/google-gson/">Gson</a> library.
</p>

<p>
    <span class="label label-info">Example</span> Returns a object as JSON:
</p>
<pre class="prettyprint">
return renderJSON(user);
</pre>

<p>
    <span class="label label-info">Example</span> Returns a map:
</p>
<pre class="prettyprint">
return renderJSON("key", user);
</pre>

<h3>Javascript script rendering: renderJSONP</h3>
<p>
    The <code>renderJSONP</code> method enables to return to the client
    a Javascript script which will execute a function by taking the passed model as parameter.
    For more information about JSONP, please refer to the 
    <a href="http://en.wikipedia.org/wiki/JSONP">Wikipedia page about JSONP</a>.
</p>

<p>
    <span class="label label-info">Example</span> Launches the test function with the user object as parameter:
</p>
<pre class="prettyprint">
return renderJSONP("myCallbackFuncton", user);
</pre>

<h3>Template rendering: renderStringTemplate</h3>
<p>
    The <code>renderStringTemplate</code> method enables to return a template
    based on <a href="http://stringtemplate.org/">StringTemplate</a> to the client.
    The base template must contain a group as follows: <code>render(model) ::= &lt;&lt; ... &gt;&gt;</code>.
    The attribute delimiter is <code>$</code>.
</p>

<p>
    <span class="label label-info">Example</span> Example of the creation of a page:
</p>
<pre class="prettyprint">
return renderStringTemplate("template.stg", "text/html",
        "title", "The title" ,
        "content", "bla bla bla ...");
</pre>
<p>
    With the followng template:
</p>
<pre class="prettyprint">
render(model) ::= &lt;&lt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;$model.title$&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        $strong(model.content)$
    &lt;/body&gt;
&lt;/html&gt;
&gt;&gt;
strong(value) ::= "&lt;strong&gt;$value$&lt;/strong&gt;"
</pre>

<h3>RSS rendering: renderRSS</h3>
<p>
    The <code>renderRSS</code> method enables to return to the client
    a RSS feed from a model which comes from ROME library.
    For more details, you can see the document on 
    <a href="http://rometools.github.io/rome/">ROME</a> library. The same model
    is used for Atom feed.
</p>

<p>
    <span class="label label-info">Example</span> Return RSS feed:
</p>
<pre class="prettyprint">
SyndFeed feed = new SyndFeedImpl();
// ...
return renderRSS(feed);
</pre>

<h3>Atom rendering : renderAtom</h3>
<p>
    The <code>renderAtom</code> method enables to return to the client
    a Atom feed from a model which comes from ROME library.
    For more details, you can see the document on 
    <a href="http://rometools.github.io/rome/">ROME</a> library. The same model
    is used for RSS feed.
</p>

<p>
    <span class="label label-info">Example</span> Return Atom feed:
</p>
<pre class="prettyprint">
SyndFeed feed = new SyndFeedImpl();
// ...
return renderAtom(feed);
</pre>

<h3>Create your own renderer</h3>
<p>
    To create a new renderer, you need to create a class inheriting the Render class
    and implementing the <code>create</code> method.
</p>

<p>
    <span class="label label-info">Example</span> XML or JSON rendering
            according to the <code>Accept</code> header of the request:
</p>
<pre class="prettyprint">
public class RenderAccept extends Render {

    protected Map&lt;String, Object&gt; model;

    public RenderAccept(Map&lt;String, Object&gt; model) {
        this.model = model;
    }

    public Map&lt;String, Object&gt; getModel() {
        return model;
    }

   @Override
   public void create(Mapping mapping, Call call) throws IOException, ServletException {
        // Get accept in header
        HttpContext context = call.getContext();
        HttpServletRequest request = context.getRequest();
        String accept = request.getHeader("Accept");

        Render render = null;
        if (accept.equals("application/json")) {
            // Delegate to renderJSON
            render = new RenderJson(model);

        } else if (accept.equals("text/xml")) {
            // Delegate to renderXML
            render = new RenderXml(model);

        } else {
            throw new IllegalArgumentException("Invalid accept");
        }

        // Create the real render
        render.create(mapping, call);
    }
}
</pre>

<h3>Default render</h3>
<p>
    In WebMotion, the return type of an action is an object of Render type. But
    it able to return an object if you define a <code>default.render</code> property in
    your mapping file. For the implementation the class needs to extend the <code>DefaultRender</code> class,
    by default this class returns the objects to JSON.
</p>

<p>
    <span class="label label-info">Example</span> Return the objects to XML format:
</p>
<pre class="prettyprint">
public class XMLDefaultRender extends DefaultRender {
    
    @Override
    public void create(Mapping mapping, Call call) throws IOException, ServletException {
        HttpContext context = call.getContext();
        HttpServletResponse response = context.getResponse();

        response.setContentType("paplication/xml");
        
        XStream xstream = new XStream();
        String xml = xstream.toXML(model);
        PrintWriter out = context.getOut();
        out.print(xml);
    }
}
</pre>

<p>
    As action :
</p>
<pre class="prettyprint">
public class Service extends WebMotionController {
    public Object test() {
        return new Object();
    }
}
</pre>

<p>
    And as mapping :
</p>
<pre class="prettyprint">
[config]
default.render=org.debux.webmotion.test.XMLDefaultRender

[actions]
GET           /test               Service.test
</pre>

<h2 class="page-header" id="websocket">WebSocket</h2>
<p>
    WebSocket is a communication protocol between the client and the server.
    It enables a permanent connection to make push/pull (bidirectional communication).
    To establish the connection, the client sends a <code>GET</code> request with specific headers.
</p>

<p>
    Prerequisites:
</p>
<ul>
    <li>for Tomcat: you need the 7.0.29 version or more</li>
    <li>for Jetty: you need the dependency to jetty-websocket</li>
    <li>
        for GlassFish: you need to activate the support with the following command
        <code>asadmin set configs.config.server-config.network-config.protocols.protocol.http-listener-1.http.websockets-support-enabled=true</code>
    </li>
</ul>

<p>
    To intercept the WebSockect call in WebMotion, you need to add a mapping rule
    on the <code>GET</code> method.
</p>
<p>
    <span class="label label-info">Example</span> Interception of a WebSocket request:
</p>
<pre>
GET           /echo/ws                    Echo.createSocket
</pre>

<p>
    The function must return a WebSockect type render. There is a simple implementation
    to send and receive messages in your WebSocket.
</p>
<pre class="prettyprint">
public class Echo extends WebMotionController {

    public Render createSocket() {
        WebMotionWebSocket socket = new EchoWebSocket();
        return new RenderWebSocket(socket);
    }

    public class EchoWebSocket extends WebMotionWebSocket {

        @Override
        public void receiveTextMessage(String message) {
            socket.sendTextMessage(message);
        }
    }
}
</pre>

<p>
    There is an implementation with the support of JSON messages.
    You need to send a message with a JSON object with the name of the method
    and the parameters to execute this method in the WebSocket.
</p>
<p>
    After the execution of this method, a message with a JSON object is returned.
    It contains the name of the executed method and the method return.
</p>
<p>
    <span class="label label-info">Example</span> Creation of a message in JavaScript:
</p>
<pre class="prettyprint">
var connection = new WebSocket(url);

connection.onopen = function () {
    var event = {
        method : "echo",
        params : {
            value : "test"
        }
    }
    connection.send(JSON.stringify(event));
};

connection.onmessage = function (e) {
    var message = JSON.parse(e.data);
    console.log(message.method);
    console.log(message.result);
};
</pre>

<p>
    With the following WebSocket:
</p>
<pre class="prettyprint">
public class EchoWebSocket extends WebMotionWebSocketJson {
    public String echo(String value) {
        return value;
    }
}
</pre>

<p>
    To retain the common parameters between WebSockets, you can use the context of the server.
    For example, you can broadcast all the WebSockets:
</p>
<pre class="prettyprint">
public class EchoWebSocket extends WebMotionWebSocket {

    @Override
    public void onOpen() {
        // Store all connections
        ServerContext serverContext = getServerContext();
        List&lt;WebMotionWebSocket&gt; connections = (List&lt;WebMotionWebSocket&gt;) serverContext.getAttribute("connections");
        if (connections == null) {
            connections = new ArrayList&lt;WebMotionWebSocket>();
            serverContext.setAttribute("connections", connections);
        }
        connections.add(this);
    }

    @Override
    public void receiveTextMessage(String message) {
        // Broadcast the message
        ServerContext serverContext = getServerContext();
        List&lt;WebMotionWebSocket&gt; connections = (List&lt;WebMotionWebSocket&gt;) serverContext.getAttribute("connections");
        for (WebMotionWebSocket socket : connections) {
            socket.sendTextMessage(message);
        }
    }
}
</pre>

<p>
    Of course, you can parameterize your method and so your WebSocket.
</p>
<pre class="prettyprint">
public class Echo extends WebMotionController {

    public Render createSocket(String who) {
        WebMotionWebSocket socket = new EchoWebSocket(who);
        return new RenderWebSocket(socket);
    }

    public class EchoWebSocket extends WebMotionWebSocket {

        protected String who;

        public EchoWebSocket(String who) {
            this.who = who;
        }

        @Override
        public void receiveTextMessage(String message) {
            socket.sendTextMessage(who + " = " + message);
        }
    }
}
</pre>

<h2 class="page-header" id="context">Web context</h2>
<p>
    All the controllers of the application can access the web context of the application,
    by calling the <code>getContext</code> method or directly in the method parameters.
    The web context gives access to all the information about the request and the response
    suche as the flash messages, the cookie management, the client session, ...
</p>

<p>
    <span class="label label-info">Example</span> Retrieving of the context in the parameters:
</p>
<pre class="prettyprint">
public class Action extends WebMotionController {
    public Render run(HttpContext context) {
        ...
        return ...
    }
    ...
}
</pre>

<p>
    <span class="label label-info">Example</span> Retrieving of the context by calling the method:
</p>
<pre class="prettyprint">
public class Action extends WebMotionController {
    public Render run() {
        HttpContext context = getContext();
        ...
        return ...
    }
    ...
}
</pre>

<p>
    You can access some data directly in the parameters of the methods.
    Once a parameter of on of the following types appears in the parameter list of a method of a controller,
    the instance will be automatically defined by WebMotion.
    You can notice that the only presence of a type provokes the dynamic definition of the object,
    the name of the parameter does not impact.
</p>
<ul>
    <li><strong>HttpContext: </strong>web context of the application</li>
    <li><strong>HttpSession: </strong>user session</li>
    <li><strong>HttpServletRequest</strong> or <strong>ServletRequest</strong>: request calling the server</li>
    <li><strong>HttpServletResponse</strong> or <strong>ServletResponse</strong>: response returned to the client</li>
    <li><strong>ServletContext: </strong> context of the servlet</li>
    <li><strong>ServerContext: </strong> context of the server</li>
    <li><strong>ErrorData: </strong>in case of error, additional information</li>
    <li><strong>Exception: </strong>in case of error, the exception which causes the error</li>
    <li><strong>FileProgressListener: </strong>enables to follow the loading progress of a file</li>
    <li><strong>Mapping: </strong>the applicative instance of the mapping</li>
    <li><strong>Config: </strong>the configuration of WebMotion</li>
    <li><strong>Properties : </strong>the configuration of the application</li>
    <li><strong>Call: </strong>the call context of the actions</li>
    <li><strong>CookieManager : </strong>the cookie manager</li>
    <li><strong>ClientSession : </strong>the client session</li>
</ul>

<p>
    <span class="label label-info">Example</span> Retrieving of the session:
</p>
<pre class="prettyprint">
public class Action extends WebMotionController {
    public Render run(HttpSession session) {
        ...
        return ...
    }
    ...
}
</pre>

<p>
    <span class="label label-info">Example</span> Retrieving of an exception:
</p>
<pre class="prettyprint">
public class Error extends WebMotionController {
    public Render display(TechnicalException exception) {
        ...
        return ...
    }
    ...
}
</pre>


<h3 id="properties">Configuration of the application</h3>
<p>
    WebMotion enables to easily manage a configuration of your application in the mapping file.
    For more details, please refer to the <a href="mapping#properties">Mapping - Configuration of the application</a>
    section. The configuration relies on the <a href="http://commons.apache.org/configuration">Apache Commons Configuration</a> library.
</p>

<p>
    <span class="label label-info">Example</span> Retrieving of the configuration in an action:
</p>
<pre class="prettyprint">
public Render run(Properties configuration) {
    ...
}
</pre>

<p>
    <span class="label label-info">Example</span> Retrieving of the configuration in the listener:
</p>
<pre class="prettyprint">
public class Listener implements WebMotionServerListener {

    @Override
    public void onStart(Mapping mapping, ServerContext context) {
        Mapping rootMapping = context.getMapping();
        Properties configuration = rootMapping.getProperties();
        ...
    }

    @Override
    public void onStop(ServerContext context) {
        // Do nothing
    }
}
</pre>

<p>
    The <code>Properties</code> object enables to retrieve the values according to different types.
</p>
<p>
    <span class="label label-info">Example</span> Retrieving of a String:
</p>
<pre class="prettyprint">
String value = configuration.getString("key");
</pre>
<p>
    With the following mapping:
</p>
<pre class="prettyprint">
[config.properties]
key=test
</pre>

<p>
    <span class="label label-info">Example</span> Retrieving of an array of String:
</p>
<pre class="prettyprint">
String[] values = configuration.getStringArray("key");
</pre>
<p>
    With the following mapping:
</p>
<pre class="prettyprint">
[config.properties]
key=test1,test2,test3
</pre>

<h3 id="flashmessage">Flash messages</h3>
<p>
    One of the difficulties of a HTTP redirection is to complete the response to inform the user
    about some temporary information. This is the goal of the flash messages,
    which are available in the HTTP context. The flash messages can be of different types:
    info, error, warning and misc. You can find them in the request as the <code>flashMessages</code> attribute.
</p>

<p>
    <span class="label label-info">Example</span> Info message:
</p>
<pre class="prettyprint">
public Render send() {
    HttpContext context = getContext();
    context.addInfoMessage("my_message", "test");
    return renderURL("/url");
}
</pre>

<p>With the following JSP message in the request:</p>
<pre class="prettyprint">
${flashMessages.infos.my_message}
</pre>

<p>
    <span class="label label-info">Example</span> Error message:
</p>
<pre class="prettyprint">
public Render send() {
    HttpContext context = getContext();
    context.addErrorMessage("my_message", "test");

    return renderURL("/url");
}
</pre>

<p>With the following JSP message in the request:</p>
<pre class="prettyprint">
${flashMessages.errors.my_message}
</pre>

<p>
    <span class="label label-info">Example</span> Warning message:
</p>
<pre class="prettyprint">
public Render send() {
    HttpContext context = getContext();
    context.addWarningMessage("my_message", "test");
    return renderURL("/url");
}
</pre>

<p>With the following JSP message in the request:</p>
<pre class="prettyprint">
${flashMessages.warnings.my_message}
</pre>

<p>
    <span class="label label-info">Example</span> Miscellaneous message:
</p>
<pre class="prettyprint">
public Render send() {
    HttpContext context = getContext();
    context.addMessage("my_message", "test");
    return renderURL("/url");
}
</pre>

<p>With the following JSP message in the request:</p>
<pre class="prettyprint">
${flashMessages.miscs.my_message}
</pre>

<p>
    <span class="label label-info">Example</span> Retrieving of all the JSP messages:
</p>
<pre class="prettyprint">
${flashMessages.messages}
</pre>

<h3 id="cookie">Cookie management</h3>
<p>
    The framework offers a cookie manager to simplify the use of the cookies,
    by offering functionalities such as the retrieving of a cookie by its name,
    the deletion of a cookie, the securisation, the handling of objects as value of a cookie, etc.
</p>

<p>
    <span class="label label-info">Example</span> Creation of a new cookie:
</p>
<pre class="prettyprint">
CookieManager manager = context.getCookieManager();
CookieEntity cookie = manager.create("name", "value");
cookie.setPath("/index.html");
manager.add(cookie);
</pre>

<p>
    <span class="label label-info">Example</span> Retrieving of a value:
</p>
<pre class="prettyprint">
CookieManager manager = context.getCookieManager();
CookieEntity cookie = manager.get("name");
String value = cookie.getValue();
</pre>

<p>
    <span class="label label-info">Example</span> Deletion of a cookie:
</p>
<pre class="prettyprint">
CookieManager manager = context.getCookieManager();
manager.remove("name");
</pre>

<p>
    <span class="label label-info">Example</span> Recording of an object as value:
</p>
<pre class="prettyprint">
CookieManager manager = context.getCookieManager();
CookieEntity cookie = manager.create("name", new User("John"));
manager.add(cookie);
</pre>

<p>
    <span class="label label-info">Example</span> Retrieving of an object as value:
</p>
<pre class="prettyprint">
CookieEntity cookie = manager.get("name");
User user = cookie.getValue(User.class);
</pre>

<p>
    It is possible to manage secure cookies. This security enables to guarantee:
</p>
<ul>
    <li>the confidentiality of the data, by using the symmetric algorithm of encryption Rijndael</li>
    <li>the integrity of the data, by creating a hash of the data</li>
    <li>a protection against the replay attacks, by integrating the SSL session Apache id</li>
    <li>a protection against the volume attacks, by integrating the name of the user</li>
</ul>
<p>
    A secret key is used to guarantee the security of the cookies.
    It is autogenerated if it is not defined in the mapping file.
    For more details, please refer to the <a href="mapping#config">Mapping - Config</a> section.
</p>

<p>
    <span class="label label-info">Example</span> Retrieving of a completely secure cookie manager:
</p>
<pre class="prettyprint">
CookieManager manager = context.getCookieManager("username", true, true);
</pre>

<p>
    Afterward, the secure cookie manager is used transparently.
    You cannot retrieve it by injecting at the level of the parameters, because
    the manager offers several levels of security (cryptography and/or SSL).
</p>

<h3 id="session">Client session</h3>
<p>
    The client session is a session stored in the form of a secure cookie on the browser of client,
    what offers a high flexibility for the scalability of your servers.
    It is used like a classical session. The session is created and saved at the time of its use.
</p>

<p>
    <span class="label label-info">Example</span> Retrieving of the client session:
</p>
<pre class="prettyprint">
public Render action(ClientSession session) {
    ...
}
</pre>

<p>
    An additional functionality is the retrieving of the attributes according to a type,
    which avoid to cast the object.
</p>

<p>
    <span class="label label-info">Example</span> Use of the client session:
</p>
<pre class="prettyprint">
session.setAttribute("name", "value");
String value = session.getAttribute("name", String.class);
</pre>

<p>
    By default, the duration of the validity of the session is classically set to 2 hours.
    You can change this value via the <code>setMaxInactiveInterval</code> method:
</p>

<pre class="prettyprint">
session.setMaxInactiveInterval(30 * 60); // 30 min
</pre>

<p>
    The client session contains a few limitations due to the storage of the cookies,
    such as the maximum size of a cookie (4 ko). Moreover, a secret key is used
    to guarantee the security of the session. It is autogenerated if it is not defined
    in the mapping file. For more details, please refer to the
    <a href="mapping#config">Mapping - Config</a> section.
</p>

<h2 class="page-header" id="validation">Validation of the parameters of the controllers</h2>
<p>
    WebMotion offers a validation of the parameters of the Java actions, according to the 303 JSR.
    For more information about this JSR, please refer to the <a href="http://jcp.org/">jcp</a> website.
    A bean is validated only if the <code>@Valid</code> or <code>@ValidGroup</code> annotations
    appears on the parameter corresponding to the called method.
    You can notice that <code>@ValidGroup</code> is the only specific annotation of the framework
    which enables the bean validation on a group.
    You can create your own validation annotations and use them with WebMotion.
</p>

<p>
    <span class="label label-info">Example</span> Simple validation:
</p>
<pre class="prettyprint">
public Render search(@NotNull String query) {
    // ...
}
</pre>

<p>
    <span class="label label-info">Example</span> Bean validation (warning, it can be null):
</p>
<pre class="prettyprint">
public Render create(@Valid Book book) {
    // ...
}
</pre>

<p>
    <span class="label label-info">Example</span> Bean validation, specifying it cannot be null:
</p>
<pre class="prettyprint">
public Render create(@Valid @NotNull Book book) {
    // ...
}
</pre>

<p>
    <span class="label label-info">Example</span> Validation of the group of a bean:
</p>
<pre class="prettyprint">
public Render comment(@ValidGroup(MyGroup.class) Book book) {
    // ...
}
</pre>

<div class="alert alert-warning">
    <p>
        <span class="label label-warning">Warning</span>&nbsp; GlassFish supports the validation of the methods only since the 3.1.2 version.
</div>

<h2 class="page-header" id="file">File loading</h2>
<p>
    The files are managed like simple parameters. WebMotion takes care of the treatment
    for the mutli-part retrieving with <a href="http://commons.apache.org/fileupload/">FileUpload</a>.
    You can use as parameter type whether the File class or the wrapper offered by WebMotion 
    to retrieve additional information about the file, ie its name, its size and its MIME type.
</p>

<p>
    <span class="label label-info">Example</span> Simple retrieving of the file:
</p>
<pre class="prettyprint">
public Render upload(File file) {
    // ...
}
</pre>

<p>
    <span class="label label-info">Example</span> Retrieving in the wrapper:
</p>
<pre class="prettyprint">
public Render upload(UploadFile file) {
    String name = file.getName();
    // ...
}
</pre>

<p>
    You can follow the evolution of the dowloading via a listener in the user session.
</p>

<p>
    <span class="label label-info">Example</span> Retrieving of information about the progress in JSON:
</p>
<pre class="prettyprint">
public Render progress(FileProgressListener listener) {
    return renderJSON(listener);
}
</pre>

<h2 class="page-header" id="tu">Tests units</h2>
<p>
    You can do a tests units to check the running of the actions. For that, you 
    have to add the following dependency to <code>test</code> scope in your project :
</p>

<pre class="prettyprint">
&lt;dependency&gt;
    &lt;groupId&gt;org.debux.webmotion&lt;/groupId&gt;
    &lt;artifactId&gt;webmotion-unittest&lt;/artifactId&gt;
    &lt;version&gt;2.5&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</pre>

<p>
    To run the tests, WebMotion uses the <a href="http://tomcat.apache.org/">Tomcat</a> 
    application web server. The tests units are compatible with <a href="http://junit.org/">JUnit</a> 
    and <a href="http://testng.org">TestNG</a>.
</p>

<p>
    <span class="label label-info">Note</span> 
    If you have the following error
    <code>java.lang.ClassNotFoundException: com.sun.faces.config.ConfigureListener</code>,
    you have to delete the dependency from <code>javaee-api</code> from compile scope.
</p>

<h3 id="junit">JUnit</h3>
<p>
    To write the tests with <a href="http://junit.org/">JUnit</a>, you have to add the dependency to JUnit library.
</p>
<pre class="prettyprint">
&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.11&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</pre>

<p>
    
    Then you have to inherit from WebMotionJUnit class :
</p>
<pre class="prettyprint">
@RunWith(JUnit4.class)
public class Example extends WebMotionJUnit {
    
    @Test
    public void testRequest() {
        // write the test
    }
    
}
</pre>

<h3 id="testng">TestNG</h3>
<p>
    To write the tests with <a href="http://testng.org">TestNG</a>, you have to add the dependency to TestNG library.
</p>
<pre class="prettyprint">
&lt;dependency&gt;
    &lt;groupId&gt;org.testng&lt;/groupId&gt;
    &lt;artifactId&gt;testng&lt;/artifactId&gt;
    &lt;version&gt;6.8&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</pre>

<p>
    Then you have to inherit from WebMotionTestNG class :
</p>
<pre class="prettyprint">
public class Example extends WebMotionTestNG {

    @Test
    public void testRequest() {
        // write the test
    }
    
}
</pre>

<h3 id="hc">Apache HttpComponents</h3>
<p>
    To write the test, you can use all client HTTP. WebMotion recommends the 
    <a href="http://hc.apache.org/">HttpComponents</a> library provided by Apache.
    WebMotion helps you with this library to give you an utility to create a request easily.    
</p>
<p>
    <span class="label label-info">Example</span> Example of creating a GET request:
</p>
<pre class="prettyprint">
String result = createRequest("/index")
        .addParameter("query", "test")
        .Get()
        .execute()
        .returnContent().asString();
</pre>

<p>
    <span class="label label-info">Exemple</span>Example of creating a POST request:
</p>
<pre class="prettyprint">
String result = createRequest("/index")
        .Post()
        .bodyForm(
            Form.form()
                .add("username", "vip")
                .add("password", "secret")
                .build()
        )
        .execute()
        .returnContent().asString();
</pre>

<h3 id="config">Configuration</h3>
<p>
    You can configure the differents elements with override the methods in abstract class.
    Be carefull you cannot have different configuration in the same tests suite.
</p>
<p>
    <span class="label label-info">Example</span> Example of changing port:
</p>
<pre class="prettyprint">
@Override
protected int getPort() {
    return 8080;
}
</pre>

<div class="well" style="text-align: center;">
    <a class="btn large" style="float:left;" href="documentation">« Documentation</a>
    <a class="btn large" style="margin: 0 auto;" href="#">Top</a>
    <a class="btn primary large" style="float:right;" href="extras">Extras »</a>
</div>

</div>
