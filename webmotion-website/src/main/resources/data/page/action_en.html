<!--
  #%L
  Webmotion website
  
  $Id$
  $HeadURL$
  %%
  Copyright (C) 2011 Debux
  %%
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as 
  published by the Free Software Foundation, either version 3 of the 
  License, or (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Lesser Public License for more details.
  
  You should have received a copy of the GNU General Lesser Public 
  License along with this program.  If not, see
  <http://www.gnu.org/licenses/lgpl-3.0.html>.
  #L%
  -->
<div id="article">

<h1>Java action</h1>

<script type="text/javascript" src="js/generated_toc.js"></script>
<div id="generated-toc" class="generate_from_h2 generate_for_article"></div>

<div class="page-header">
    <h2 id="controller">WebMotionController</h2>
</div>
<p>
    In WebMotion, if you decide that the treatment to perform for a given URL
    is to execute Java code, then the called method must be a method of a class
    inheriting <a href="http://projects.debux.org/project-site/webmotion/apidocs/org/debux/webmotion/server/WebMotionController.html">WebMotionController</a>.
    This class has the following features:
</p>

<ul>
    <li>possibility of returning a rendering (adding information in the HTTP response, such as a web page, a JSON stream, etc.) ;</li>
    <li>access to the web context (which gives access to the user session, the request, the response, etc.) ;</li>
    <li>possibility of creating &laquo;&nbsp;flash&nbsp;&raquo; messages to return messages to the user (time-sensitive messages) ;</li>
    <li>possibility of validating the parameters of the called method with annotations.</li>
</ul>

<pre class="prettyprint">
public class User extends WebMotionController {
    public Render find(String id) {
        ...
        return ...
    }
    ...
}
</pre>

<p>
    All the controllers in WebMotion are instantiated only once (singleton pattern).
    They are made to be used stateless, so it is strongly recommended not to create instance variables in the controllers,
    unless you are really sure of what you are doing!
</p>

<div class="page-header">
    <h2 id="render">Different kinds of rendering</h2>
</div>
<p>
    A rendering is the response returned to the client which made a request to the server.
    The renderings can be returned whether in a filter or in a controller.
</p>
<p>
    It frequently happens that a rendering is generated by using a linked model.
    <strong>The model is transmitted with a set of key/value pairs.</strong>
</p>

<h3>Page rendering: renderView</h3>
<p>
    The renderView() method, called in a method of a WebMotionController,
    enables to return a resource (typically a web page, JSP, HTML, plain text) to the client.
    In this case, the model is passed as an attribute of the request (refer to the
    <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/ServletRequest.html#setAttribute(java.lang.String,%20java.lang.Object)">
        ServletRequest.setAttribute()
    </a> method).
</p>

<p>
    <span class="label label-info">Example</span> Returns a JSP page:
</p>
<pre class="prettyprint">
return renderView("index.jsp");
</pre>

<p>
    <span class="label label-info">Example</span> Returns a html page:
</p>
<pre class="prettyprint">
return renderView("index.html");
</pre>

<p>
    <span class="label label-info">Example</span> Returns a html page in the page directory:
</p>
<pre class="prettyprint">
return renderView("page/index.html");
</pre>

<p>
    <span class="label label-info">Example</span> Returns a JSP page with the model:
</p>
<pre class="prettyprint">
return renderView("index.jsp", "name", "value");
</pre>
<p>Avec la page JSP :</p>
<pre>
Value = ${name}
</pre>

<h3>HTTP redirection: renderURL</h3>
<p>
    This kind of rendering enables to redirect the web client to another URL.
    It can be an absolute URL (eg an external domain) as well as a URL relative to the current path.
    By default, the URLs are relative to the extension. To call a path out of the extension,
    you need to specify <code>/deploy</code> at the begining of your URL.
</p>
<p>
    A HTTP redirection can be useful to redirect the user after the submission of a form.
    In this kind of rendering, the model is added to the parameters of the redirection URL.
</p>

<p>
    <span class="label label-info">Example</span> Relative URL:
</p>
<pre class="prettyprint">
return renderURL("/display");
</pre>

<p>
    <span class="label label-info">Example</span> Absolute URL:
</p>
<pre class="prettyprint">
return renderURL("http://www.google.fr");
</pre>

<p>
    <span class="label label-info">Example</span> Relative URL with a model:
</p>
<pre class="prettyprint">
// The user will be redirected to the /user?id=1232323&amp;action=view address
return renderURL("/user", "id", 1232323, "action", "view");
</pre>

<h3>Redirection to another controller: renderAction</h3>
<p>
    The redirection to another controller enables to link several actions
    and to return the rendering of the last contoller.
    In this case, the model passed in the parameters is directly in the parameters of the called controller.
</p>

<p>
    <span class="label label-info">Example</span> Direct call:
</p>
<pre class="prettyprint">
public class Call extends WebMotionController {
    public Render action() {
        // ...
        return next("test");
    }

    public Render next(String value) {
        // ...
    }
}
</pre>

<p>
    <span class="label label-info">Example</span> Indirect call:
</p>
<pre class="prettyprint">
public class Call extends WebMotionController {
    public Render action() {
        // ...
        return renderAction("Call.next", "test");
    }

    public Render next(String value) {
        // ...
    }
}
</pre>

<h3>Forward to another controller: renderActionUrl</h3>
<p>
    The forward to another controller enables to link several actions
    and to return the rendering of the last controller by using the a URL in the mapping,
    without redirection at the client level.
    In this case, the model passed in the parameters is directly in the parameters of the called controller.
    By default, the URLs are relative to the extension. To call a path out of the extension,
    you need to specify <code>/deploy</code> at the begining of your URL.
</p>

<p>
    <span class="label label-info">Example</span> Call of an internal action via the URL:
</p>
<pre class="prettyprint">
return renderActionURL("/internal/action", "param", "internal");
</pre>

<p>
    With the following action:
</p>
<pre class="prettyprint">
public Render action(String param) {
    return ...
}
</pre>

<h3>Rendering of contents: renderContent</h3>
<p>
    The <code>renderContent(String content, String mimeType)</code> method enables to return
    directly the string which will be interpreted by the client as the specified MIME type.
</p>

<p>
    <span class="label label-info">Example</span> Direct HTML rendering:
</p>
<pre class="prettyprint">
// Displaysra "example" as an h1 title
return renderContent("&lt;h1&gt;example&lt;/h1&gt;", "text/html");
</pre>

<p>
    <span class="label label-info">Example</span> Direct plain text rendering:
</p>
<pre class="prettyprint">
// Displays "&lt;h1&gt;example&lt;/h1&gt;"
return renderContent("&lt;h1&gt;example&lt;/h1&gt;", "text/plain");
</pre>

<h3>Stream redering: renderStream</h3>
<p>
    The <code>renderContent(InputStream stream, String mimeType)</code> method
    enables to return directly a stream in the response, which will be interpreted
    as the specified MIME type.
</p>

<p>
    <span class="label label-info">Example</span> Returns a PDF document in the classpath:
</p>
<pre class="prettyprint">
ClassLoader classLoader = Stream.class.getClassLoader();
InputStream stream = classLoader.getResourceAsStream("doc.pdf");
return renderStream(stream, "application/pdf");
</pre>

<p>
    <span class="label label-info">Example</span> Returns an image in the classpath:
</p>
<pre class="prettyprint">
ClassLoader classLoader = Stream.class.getClassLoader();
InputStream stream = classLoader.getResourceAsStream("logo.png");
return renderStream(stream, "image/png");
</pre>

<h3>Rendu pour le téléchargement : renderDownload</h3>
<p>
    La méthode <code>renderDownload(InputStream stream, String name, String mimeType)</code>
    permet de retourner le flux en attachement dans la réponse pour provoquer le téléchargement
    du fichier par le navigateur.
</p>

<p>
    <span class="label label-info">Example</span> Retourne un document PDF présent dans le classpath :
</p>
<pre class="prettyprint">
ClassLoader classLoader = Stream.class.getClassLoader();
InputStream stream = classLoader.getResourceAsStream("doc.pdf");
return renderDownload(stream, "file.pdf", "application/pdf");
</pre>

<p>
    <span class="label label-info">Example</span> Retourne une image présente dans le classpath :
</p>
<pre class="prettyprint">
ClassLoader classLoader = Stream.class.getClassLoader();
InputStream stream = classLoader.getResourceAsStream("logo.png");
return renderDownload(stream, "image.pdf", "image/png");
</pre>

<h3>Rechargement de page : renderLastPage</h3>
<p>
    La méthode <code>renderLastPage()</code> permet de rafraîchir la page courante, 
    elle utilise le referer dans le header HTTP de la requête.
</p>

<p>
    <span class="label label-info">Example</span> Recharge la page :
</p>
<pre class="prettyprint">
return renderLastPage();
</pre>

<p>
    <span class="label label-info">Example</span> Recharge la page en passant des paramètres supplémentaires :
</p>
<pre class="prettyprint">
return renderLastPage("id", 122345);
</pre>

<h3>Retour de code HTTP : renderStatus</h3>
<p>
    La méthode <code>renderStatus(int status)</code> permet de retourner
    au client un code statut HTTP. Il est possible d'utiliser les constantes 
    présentes dans l'interface
    <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletResponse.html">
        HttpServletResponse
    </a>.
</p>

<p>
    <span class="label label-info">Example</span> Retourne un 200 comme ping :
</p>
<pre class="prettyprint">
return renderStatus(HttpServletResponse.SC_OK);
</pre>

<h3>Retour d'erreur : renderError</h3>
<p>
    La méthode <code>renderError(int status, String message)</code> permet de retourner
    au client un code d'erreur HTTP. Il est possible d'utiliser les constantes 
    présentes dans l'interface
    <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletResponse.html">
        HttpServletResponse
    </a>.
</p>

<p>
    <span class="label label-info">Example</span> Retourne une erreur 404 à l'utilisateur :
</p>
<pre class="prettyprint">
return renderError(HttpServletResponse.SC_NOT_FOUND, "Not found");
</pre>

<h3>Rendu de flux XML : renderXML</h3>
<p>
    La méthode <code>renderXML</code> permet de retourner
    au client la représentation XML de l'objet Java passé en paramètre.
    La sérialisation XML est effectuée à l'aide de la bibliothèque 
    <a href="http://xstream.codehaus.org/">XStream</a>.
</p>

<p>
    <span class="label label-info">Example</span> Retourne un objet en xml :
</p>
<pre class="prettyprint">
User user = new User("John", "Brown");
return renderXML(user);
</pre>

<p>
    <span class="label label-info">Example</span> Retourne une map :
</p>
<pre class="prettyprint">
return renderXML("key", user);
</pre>

<h3>Rendu de flux JSON : renderJSON</h3>
<p>
    La méthode <code>renderJSON</code> permet de retourner
    au client la représentation JSON de l'objet Java passé en paramètre.
    La sérialisation JSON est effectuée à l'aide de la bibliothèque 
    <a href="https://code.google.com/p/google-gson/">Gson</a>.
</p>

<p>
    <span class="label label-info">Example</span> Retourne un objet en JSON :
</p>
<pre class="prettyprint">
return renderJSON(user);
</pre>

<p>
    <span class="label label-info">Example</span> Retourne une map :
</p>
<pre class="prettyprint">
return renderJSON("key", user);
</pre>

<h3>Rendu de script javascript : renderJSONP</h3>
<p>
    La méthode <code>renderJSONP</code>
    permet de retourner au client un script Javascript qui exécutera une 
    fonction en prenant en paramètre le modèle qui sera passé.
    Pour plus de détails à propos de JSONP, voir la
    <a href="http://en.wikipedia.org/wiki/JSONP">page Wikipedia traitant de JSONP</a>.
</p>

<p>
    <span class="label label-info">Example</span> Lance la fonction test avec l'objet user en paramètre :
</p>
<pre class="prettyprint">
return renderJSONP("myCallbackFuncton", user);
</pre>

<h3>Rendu d'un template : renderStringTemplate</h3>
<p>
    La méthode <code>renderStringTemplate</code>
    permet de retourner au client un template basé sur <a href="http://stringtemplate.org/">StringTemplate</a>.
    Le template de base doit contenir un groupe de la façon suivante <code>render(model) ::= &lt;&lt; ... &gt;&gt;</code>.
    Le délimitateur des attributs est <code>$</code>.
</p>

<p>
    <span class="label label-info">Example</span> Example d'une creation de page  :
</p>
<pre class="prettyprint">
return renderStringTemplate("template.stg", "text/html",
        "title", "The title" ,
        "content", "bla bla bla ...");
</pre>
<p>
    Avec comme template :
</p>
<pre class="prettyprint">
render(model) ::= &lt;&lt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;$model.title$&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        $strong(model.content)$
    &lt;/body&gt;
&lt;/html&gt;
&gt;&gt;
strong(value) ::= "&lt;strong&gt;$value$&lt;/strong&gt;"
</pre>


<h3>Créer son propre moteur de rendu</h3>
<p>
    Pour créer un nouveau moteur de rendu, il faut créer une classe héritant de la classe Render et
    réimplémenter la méthode <code>create</code>.
</p>

<p>
    <span class="label label-info">Example</span> Rendu XML ou JSON selon l'en-tête <code>Accept</code> de la requête :
</p>
<pre class="prettyprint">
public class RenderAccept extends Render {

    protected Map&lt;String, Object&gt; model;

    public RenderAccept(Map&lt;String, Object&gt; model) {
        this.model = model;
    }

    public Map&lt;String, Object&gt; getModel() {
        return model;
    }

   @Override
   public void create(Mapping mapping, Call call) throws IOException, ServletException {
        // Get accept in header
        HttpContext context = call.getContext();
        HttpServletRequest request = context.getRequest();
        String accept = request.getHeader("Accept");

        Render render = null;
        if (accept.equals("application/json")) {
            // Delegate to renderJSON
            render = new RenderJson(model);

        } else if (accept.equals("text/xml")) {
            // Delegate to renderXML
            render = new RenderXml(model);

        } else {
            throw new IllegalArgumentException("Invalid accept");
        }

        // Create the real render
        render.create(mapping, call);
    }
}
</pre>

<div class="page-header">
    <h2 id="context">Contexte web</h2>
</div>
<p>
    Tous les contrôleurs de l'application ont accès au contexte web de l'application,
    soit par le biais de la méthode <code>getContext</code> soit directement en paramètre de la méthode.
</p>

<p>
    <span class="label label-info">Example</span> Recupération du context par paramètre :
</p>
<pre class="prettyprint">
public class Action extends WebMotionController {
    public Render run(HttpContext context) {
        ...
        return ...
    }
    ...
}
</pre>

<p>
    <span class="label label-info">Example</span> Recupération du context par méthode :
</p>
<pre class="prettyprint">
public class Action extends WebMotionController {
    public Render run() {
        HttpContext context = getContext();
        ...
        return ...
    }
    ...
}
</pre>

<p>
    Il est possible d'accéder à un certains nombre de données directement en paramètre des méthodes.
    Dès lors qu'un paramètre de l'un des types suivants apparaît dans la liste des paramètres d'une méthode
    d'un contrôleur, l'instance sera automatiquement définie par WebMotion. Il est à noter que seule la présence
    du type provoque la définition dynamique de l'objet, le nom du paramètre n'influe pas. 
</p>
<ul>
    <li><strong>HttpContext : </strong>contexte web de l'application</li>
    <li><strong>HttpSession : </strong>session utilisateur</li>
    <li><strong>HttpServletRequest</strong> ou <strong>ServletRequest</strong> : requête appelant le serveur</li>
    <li><strong>HttpServletResponse</strong> ou <strong>ServletResponse</strong> : réponse retournée au client</li>
    <li><strong>ServletContext : </strong> contexte de la servlet</li>
    <li><strong>ServerContext : </strong> contexte du serveur</li>
    <li><strong>ErrorData : </strong>en cas d'erreur, des informations complémentaires</li>
    <li><strong>Exception : </strong>en cas d'erreur, l'exception responsable de l'erreur</li>
    <li><strong>FileProgressListener : </strong>permet de suivre la progression de chargement de fichier</li>
    <li><strong>Mapping : </strong>l'instance applicative du mapping</li>
    <li><strong>Config : </strong>la configuration du mapping applicatif</li>
    <li><strong>Call : </strong>le contexte d'appel des actions</li>
</ul>

<p>
    <span class="label label-info">Example</span> Recupération de la session :
</p>
<pre class="prettyprint">
public class Action extends WebMotionController {
    public Render run(HttpSession session) {
        ...
        return ...
    }
    ...
}
</pre>

<p>
    <span class="label label-info">Example</span> Recupération d'une exception :
</p>
<pre class="prettyprint">
public class Error extends WebMotionController {
    public Render display(TechnicalException exception) {
        ...
        return ...
    }
    ...
}
</pre>

<div class="page-header">
    <h2 id="flashmessage">Messages flash</h2>
</div>
<p>
    L'une des difficultés lors d'une redirection HTTP est de compléter la réponse pour informer l'utilisateur d'une information temporaire. 
    Les messages flash ont ce but, et sont disponibles dans le contexte HTTP. Les messages flash peuvent être de différents types : info, error, warning et misc.
    Ils sont récupérables dans la requête par l'attibut <code>flashMessages</code>.
</p>

<p>
    <span class="label label-info">Example</span> Message d'info :
</p>
<pre class="prettyprint">
public Render send() {
    HttpContext context = getContext();
    context.addInfoMessage("my_message", "test");
    return renderURL("/url");
}
</pre>

<p>Avec comme récupération dans la request du message en JSP :</p>
<pre class="prettyprint">
${flashMessages.infos.my_message}
</pre>

<p>
    <span class="label label-info">Example</span> Message d'erreur :
</p>
<pre class="prettyprint">
public Render send() {
    HttpContext context = getContext();
    context.addErrorMessage("my_message", "test");

    return renderURL("/url");
}
</pre>

<p>Avec comme récupération dans la request du message en JSP :</p>
<pre class="prettyprint">
${flashMessages.errors.my_message}
</pre>

<p>
    <span class="label label-info">Example</span> Message d'avertissement :
</p>
<pre class="prettyprint">
public Render send() {
    HttpContext context = getContext();
    context.addWarningMessage("my_message", "test");
    return renderURL("/url");
}
</pre>

<p>Avec comme récupération dans la request du message en JSP :</p>
<pre class="prettyprint">
${flashMessages.warnings.my_message}
</pre>

<p>
    <span class="label label-info">Example</span> Message divers :
</p>
<pre class="prettyprint">
public Render send() {
    HttpContext context = getContext();
    context.addMessage("my_message", "test");
    return renderURL("/url");
}
</pre>

<p>Avec comme récupération dans la request du message en JSP :</p>
<pre class="prettyprint">
${flashMessages.miscs.my_message}
</pre>

<p>
    <span class="label label-info">Example</span> Récupérations de l'ensemble des messages en jsp :
</p>
<pre class="prettyprint">
${flashMessages.messages}
</pre>

<div class="page-header">
    <h2 id="validation">Validation des paramètres des contrôleurs</h2>
</div>
<p>
    WebMotion propose une validation des paramètres des actions Java, sur la JSR 303.
    Pour plus de renseignement sur la JSR, vous pouvez consulter le site <a href="http://jcp.org/">jcp</a>.
    Un bean ne sera validé uniquement si les annotations <code>@Valid</code> ou <code>@ValidGroup</code>
    apparaissent sur le paramètre correspondant dans la méthode appellée.
    Il faut noter que <code>@ValidGroup</code> est la seule annotation 
    propre au framework qui permet la validation du bean sur un groupe.
    Il est possible de créer ses propres annotations de validation et les utiliser avec WebMotion.
</p>

<p>
    <span class="label label-info">Example</span> Validation simple :
</p>
<pre class="prettyprint">
public Render search(@NotNull String query) {
    // ...
}
</pre>

<p>
    <span class="label label-info">Example</span> Validation sur un bean, attention il peut être null :
</p>
<pre class="prettyprint">
public Render create(@Valid Book book) {
    // ...
}
</pre>

<p>
    <span class="label label-info">Example</span> Validation sur un bean, en précisant qu'il ne peut être null :
</p>
<pre class="prettyprint">
public Render create(@Valid @NotNull Book book) {
    // ...
}
</pre>

<p>
    <span class="label label-info">Example</span> Validation d'un groupe sur un bean  :
</p>
<pre class="prettyprint">
public Render comment(@ValidGroup(MyGroup.class) Book book) {
    // ...
}
</pre>

<div class="alert alert-warning">
    <p>
        <span class="label label-warning">Attention</span>&nbsp; GlassFish supporte la validation sur les méthodes qu'à partir de la version 3.1.2.
</div>

<div class="page-header">
    <h2 id="file">Chargement de fichiers</h2>
</div>
<p>
    Les fichiers sont gérés comme des paramètres simples. WebMotion s'occupe avec l'aide
    de <a href="http://commons.apache.org/fileupload/">FileUpload</a> de faire le traitement 
    pour la récupération multi-part. Il est possible d'utiliser, comme type de paramètre, soit la classe File, 
    soit le wrapper proposer par WebMotion pour récupérer des informations complémentaires sur le fichier, à savoir
    son nom, sa taille et son type mime.
</p>

<p>
    <span class="label label-info">Example</span> Récupération simple du fichier  :
</p>
<pre class="prettyprint">
public Render upload(File file) {
    // ...
}
</pre>

<p>
    <span class="label label-info">Example</span> Récupération par le wrapper  :
</p>
<pre class="prettyprint">
public Render upload(UploadFile file) {
    String name = file.getName();
    // ...
}
</pre>

<p>
    Il est possible de suivre l'évolution du téléchargement par le biais d'un 
    écouteur mis à disposition dans la session de l'utilisateur.
</p>

<p>
    <span class="label label-info">Example</span> Récupération des informations de progression en format JSON  :
</p>
<pre class="prettyprint">
public Render progress(FileProgressListener listener) {
    return renderJSON(listener);
}
</pre>

<div class="well" style="text-align: center;">
    <a class="btn large" style="float:left;" href="documentation">« Documentation</a>
    <a class="btn large" style="margin: 0 auto;" href="#">Haut de page</a>
    <a class="btn primary large" style="float:right;" href="extensions">Extensions »</a>
</div>

</div>
