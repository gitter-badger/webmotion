<!--
  #%L
  Webmotion website
  
  $Id$
  $HeadURL$
  %%
  Copyright (C) 2011 Debux
  %%
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as 
  published by the Free Software Foundation, either version 3 of the 
  License, or (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Lesser Public License for more details.
  
  You should have received a copy of the GNU General Lesser Public 
  License along with this program.  If not, see
  <http://www.gnu.org/licenses/lgpl-3.0.html>.
  #L%
  -->
<div id="article">

<h1>Action Java</h1>

<script type="text/javascript" src="js/generated_toc.js"></script>
<div id="generated-toc" class="generate_from_h2 generate_for_article"></div>

<h2 class="page-header" id="controller">WebMotionController</h2>
<p>
    Dans WebMotion, il l'on décide que le traitement à exécuter pour une URL donnée
    est l'exécution de code Java, la méthode appelée doit être une méthode d'une 
    classe héritant de 
    <a href="http://projects.debux.org/project-site/webmotion/apidocs/org/debux/webmotion/server/WebMotionController.html">WebMotionController</a>.
    Cette classe bénéficie notamment des fonctionnalités suivantes :
</p>

<ul>
    <li>possibilité de retourner un rendu (ajout d'informations dans la réponse HTTP, telles qu'une page web, un flux JSON, etc.) ;</li>
    <li>accès au contexte web (qui donne accès à la session utilisateur, à la requête, la réponse, etc.) ;</li>
    <li>possibilité de créer des messages dits &laquo;&nbsp;flash&nbsp;&raquo;, pour renvoyer des messages à l'utilisateur (messages périmables dans le temps) ;</li>
    <li>possibilité de valider par annotation les paramètres de la méthode appelée.</li>
</ul>

<pre class="prettyprint">
public class User extends WebMotionController {
    public Render find(String id) {
        ...
        return ...
    }
    ...
}
</pre>

<p>
    L'ensemble des contrôleurs dans WebMotion sont instanciés une seule et unique fois (pattern singleton).
    Ils sont faits pour être utilisés sans notion d'état (stateless), il est donc fortement déconseillé
    de créer des variables d'instance dans les contrôleurs, à moins que vous soyez sûr de ce que vous faites !
</p>

<h2 class="page-header" id="render">Les différents types de rendus</h2>
<p>
    Un rendu est la réponse retournée au client qui a fait une requête au serveur.
    Les rendus peuvent retourné soit dans un filtre, soit dans un contrôleur.
</p>
<p>
    Il arrive fréquemment que le rendu soit généré en utilisant un modèle qui lui est lié.
    <strong>Le modèle est transmis par un ensemble de couples clé / valeur.</strong>
</p>

<h3>Rendu de pages : renderView</h3>
<p>
    La méthode <code>renderView</code>, appelée dans une méthode d'un WebMotionControlleur,
    permet de retourner au client une ressource (typiquement, une page web, JSP, HTML, texte brut).
    Dans ce cas là, le modèle est passé en attribut de la requête (voir la méthode 
    <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/ServletRequest.html#setAttribute(java.lang.String,%20java.lang.Object)">
        ServletRequest.setAttribute()
    </a>).
</p>

<p>
    <span class="label label-info">Exemple</span> Retourne une page JSP :
</p>
<pre class="prettyprint">
return renderView("index.jsp");
</pre>

<p>
    <span class="label label-info">Exemple</span> Retourne une page html :
</p>
<pre class="prettyprint">
return renderView("index.html");
</pre>

<p>
    <span class="label label-info">Exemple</span> Retourne une page html dans le répertoire page :
</p>
<pre class="prettyprint">
return renderView("page/index.html");
</pre>

<p>
    <span class="label label-info">Exemple</span> Retourne une page JSP avec un model :
</p>
<pre class="prettyprint">
return renderView("index.jsp", "name", "value");
</pre>
<p>Avec la page JSP :</p>
<pre>
Value = ${name}
</pre>

<h3>Redirection HTTP : renderURL or renderRedirect</h3>
<p>
    Ce type de rendu permet de rediriger le client web vers une autre URL.
    Il peut s'agir aussi bien d'une URL absolue (domaine externe, par exemple)
    que d'une URL relative au chemin courant.
    Par défaut les urls sont relatives à l'extension, pour appeler un path en dehors de l'extension,
    il faut préciser <code>/deploy</code> en début de votre url.
</p>
<p>
    Une redirection HTTP peut être utile pour rediriger l'utilisateur après la soumission d'un formulaire.
    Dans ce type de rendu, le modèle est ajouté en paramètre dans l'URL de redirection.
</p>

<p>
    <span class="label label-info">Exemple</span> URL relative :
</p>
<pre class="prettyprint">
return renderURL("/display");
// ou
return renderRedirect("/display");
</pre>

<p>
    <span class="label label-info">Exemple</span> URL absolue :
</p>
<pre class="prettyprint">
return renderURL("http://www.google.fr");
// ou
return renderRedirect("http://www.google.fr");
</pre>

<p>
    <span class="label label-info">Exemple</span> URL relative avec un modèle :
</p>
<pre class="prettyprint">
// L'utilisateur sera redirigé vers l'adresse /user?id=1232323&amp;action=view
return renderURL("/user", "id", 1232323, "action", "view");
</pre>

<h3>Redirection vers un autre contrôleur : renderAction</h3>
<p>
    La redirection vers un autre contrôleur permet d'enchaîner plusieurs actions et de retourner
    le rendu du dernier contrôleur.
    Dans ce cas là, le modèle passé en paramètre se retrouve directement en paramètre du contrôleur appelé.
</p>

<p>
    <span class="label label-info">Exemple</span> Appel direct :
</p>
<pre class="prettyprint">
public class Call extends WebMotionController {
    public Render action() {
        // ...
        return next("test");
    }

    public Render next(String value) {
        // ...
    }
}
</pre>

<p>
    <span class="label label-info">Exemple</span> Appel indirect :
</p>
<pre class="prettyprint">
public class Call extends WebMotionController {
    public Render action() {
        // ...
        return renderAction("Call.next", "test");
    }

    public Render next(String value) {
        // ...
    }
}
</pre>

<h3>Forward vers un autre contrôleur : renderForward</h3>
<p>
    
    Le forward vers un autre contrôleur permet d'enchaîner plusieurs actions et de retourner
    le rendu du dernier contrôleur en utilisant une url dans le mapping, sans redirection au niveau du client.
    Dans ce cas là, le modèle passé en paramètre se retrouve directement en paramètre du contrôleur appelé.
    Par défaut les urls sont relatives à l'extension, pour appeler un path en dehors de l'extension,
    il faut préciser <code>/deploy</code> en début de votre url.
</p>

<p>
    <span class="label label-info">Exemple</span> Appel d'une action interne par l'url :
</p>
<pre class="prettyprint">
return renderForward("/internal/action", "param", "internal");
</pre>

<p>
    Avec comme action :
</p>
<pre class="prettyprint">
public Render action(String param) {
    return ...
}
</pre>

<p>
    <span class="label label-info">Exemple</span> Appel d'une action interne par l'url avec des attributs :
</p>
<pre class="prettyprint">
return renderForward("/internal/action", new Object[]{"param", "internal"}, new Object[]{"att", "value"});
</pre>

<h3>Rendu de contenu : renderContent</h3>
<p>
    La méthode <code>renderContent</code> permet de retourner 
    directement qui chaîne de caractères qui sera interprêtée par le client sous le type mime spécifié.
</p>

<p>
    <span class="label label-info">Exemple</span> Rendu direct en HTML :
</p>
<pre class="prettyprint">
// Affichera "exemple" dans le style de titre h1
return renderContent("&lt;h1&gt;exemple&lt;/h1&gt;", "text/html");
</pre>

<p>
    <span class="label label-info">Exemple</span> Rendu direct en text brut :
</p>
<pre class="prettyprint">
// Affichera "&lt;h1&gt;exemple&lt;/h1&gt;"
return renderContent("&lt;h1&gt;exemple&lt;/h1&gt;", "text/plain");
</pre>

<h3>Rendu de flux : renderStream</h3>
<p>
    La méthode <code>renderContent</code>
    permet de retourner directement un flux dans la réponse, qui sera interprêté 
    selon le type mime spécifié.
</p>

<p>
    <span class="label label-info">Exemple</span> Retourne un document PDF présent dans le classpath :
</p>
<pre class="prettyprint">
ClassLoader classLoader = Stream.class.getClassLoader();
InputStream stream = classLoader.getResourceAsStream("doc.pdf");
return renderStream(stream, "application/pdf");
</pre>

<p>
    <span class="label label-info">Exemple</span> Retourne une image présente dans le classpath :
</p>
<pre class="prettyprint">
ClassLoader classLoader = Stream.class.getClassLoader();
InputStream stream = classLoader.getResourceAsStream("logo.png");
return renderStream(stream, "image/png");
</pre>

<h3>Rendu pour le téléchargement : renderDownload</h3>
<p>
    La méthode <code>renderDownload</code>
    permet de retourner le flux en attachement dans la réponse pour provoquer le téléchargement
    du fichier par le navigateur.
</p>

<p>
    <span class="label label-info">Exemple</span> Retourne un document PDF présent dans le classpath :
</p>
<pre class="prettyprint">
ClassLoader classLoader = Stream.class.getClassLoader();
InputStream stream = classLoader.getResourceAsStream("doc.pdf");
return renderDownload(stream, "file.pdf", "application/pdf");
</pre>

<p>
    <span class="label label-info">Exemple</span> Retourne une image présente dans le classpath :
</p>
<pre class="prettyprint">
ClassLoader classLoader = Stream.class.getClassLoader();
InputStream stream = classLoader.getResourceAsStream("logo.png");
return renderDownload(stream, "image.pdf", "image/png");
</pre>

<h3>Rechargement de page : renderLastPage</h3>
<p>
    La méthode <code>renderLastPage</code> permet de rafraîchir la page courante, 
    elle utilise le referer dans le header HTTP de la requête.
</p>

<p>
    <span class="label label-info">Exemple</span> Recharge la page :
</p>
<pre class="prettyprint">
return renderLastPage();
</pre>

<p>
    <span class="label label-info">Exemple</span> Recharge la page en passant des paramètres supplémentaires :
</p>
<pre class="prettyprint">
return renderLastPage("id", 122345);
</pre>

<h3>Retour de code HTTP : renderStatus</h3>
<p>
    La méthode <code>renderStatus</code> permet de retourner
    au client un code statut HTTP. Il est possible d'utiliser les constantes 
    présentes dans l'interface
    <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletResponse.html">
        HttpServletResponse
    </a>.
</p>

<p>
    <span class="label label-info">Exemple</span> Retourne un code HTTP 200 comme ping :
</p>
<pre class="prettyprint">
return renderStatus(HttpServletResponse.SC_OK);
</pre>

<p>
    <span class="label label-info">Exemple</span> Raccourci pour retourner un code HTTP 200 à l'utilisateur :
</p>
<pre class="prettyprint">
return renderSuccess();
</pre>

<h3>Retour d'erreur : renderError</h3>
<p>
    La méthode <code>renderError</code> permet de retourner
    au client un code d'erreur HTTP. Il est possible d'utiliser les constantes 
    présentes dans l'interface
    <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletResponse.html">
        HttpServletResponse
    </a>.
</p>

<p>
    <span class="label label-info">Exemple</span> Retourne une erreur 404 à l'utilisateur :
</p>
<pre class="prettyprint">
return renderError(HttpServletResponse.SC_NOT_FOUND);
</pre>

<p>
    <span class="label label-info">Exemple</span> Retourne une erreur 404 à l'utilisateur avec un message :
</p>
<pre class="prettyprint">
return renderError(HttpServletResponse.SC_NOT_FOUND, "Not found because ...");
</pre>

<p>
    <span class="label label-info">Exemple</span> Raccourci pour retourner une erreur 500 à l'utilisateur :
</p>
<pre class="prettyprint">
return renderFailure();
</pre>

<h3>Rendu de flux XML : renderXML</h3>
<p>
    La méthode <code>renderXML</code> permet de retourner
    au client la représentation XML de l'objet Java passé en paramètre.
    La sérialisation XML est effectuée à l'aide de la bibliothèque 
    <a href="http://xstream.codehaus.org/">XStream</a>.
</p>

<p>
    <span class="label label-info">Exemple</span> Retourne un objet en xml :
</p>
<pre class="prettyprint">
User user = new User("John", "Brown");
return renderXML(user);
</pre>

<p>
    <span class="label label-info">Exemple</span> Retourne une map :
</p>
<pre class="prettyprint">
return renderXML("key", user);
</pre>

<h3>Rendu de flux JSON : renderJSON</h3>
<p>
    La méthode <code>renderJSON</code> permet de retourner
    au client la représentation JSON de l'objet Java passé en paramètre.
    La sérialisation JSON est effectuée à l'aide de la bibliothèque 
    <a href="https://code.google.com/p/google-gson/">Gson</a>.
</p>

<p>
    <span class="label label-info">Exemple</span> Retourne un objet en JSON :
</p>
<pre class="prettyprint">
return renderJSON(user);
</pre>

<p>
    <span class="label label-info">Exemple</span> Retourne une map :
</p>
<pre class="prettyprint">
return renderJSON("key", user);
</pre>

<h3>Rendu de script javascript : renderJSONP</h3>
<p>
    La méthode <code>renderJSONP</code>
    permet de retourner au client un script Javascript qui exécutera une 
    fonction en prenant en paramètre le modèle qui sera passé.
    Pour plus de détails à propos de JSONP, voir la
    <a href="http://en.wikipedia.org/wiki/JSONP">page Wikipedia traitant de JSONP</a>.
</p>

<p>
    <span class="label label-info">Exemple</span> Lance la fonction test avec l'objet user en paramètre :
</p>
<pre class="prettyprint">
return renderJSONP("myCallbackFuncton", user);
</pre>

<h3>Rendu d'un template : renderStringTemplate</h3>
<p>
    La méthode <code>renderStringTemplate</code>
    permet de retourner au client un template basé sur <a href="http://stringtemplate.org/">StringTemplate</a>.
    Le template de base doit contenir un groupe de la façon suivante <code>render(model) ::= &lt;&lt; ... &gt;&gt;</code>.
    Le délimitateur des attributs est <code>$</code>.
</p>

<p>
    <span class="label label-info">Exemple</span> Exemple d'une creation de page  :
</p>
<pre class="prettyprint">
return renderStringTemplate("template.stg", "text/html",
        "title", "The title" ,
        "content", "bla bla bla ...");
</pre>
<p>
    Avec comme template :
</p>
<pre class="prettyprint">
render(model) ::= &lt;&lt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;$model.title$&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        $strong(model.content)$
    &lt;/body&gt;
&lt;/html&gt;
&gt;&gt;
strong(value) ::= "&lt;strong&gt;$value$&lt;/strong&gt;"
</pre>


<h3>Créer son propre moteur de rendu</h3>
<p>
    Pour créer un nouveau moteur de rendu, il faut créer une classe héritant de la classe Render et
    réimplémenter la méthode <code>create</code>.
</p>

<p>
    <span class="label label-info">Exemple</span> Rendu XML ou JSON selon l'en-tête <code>Accept</code> de la requête :
</p>
<pre class="prettyprint">
public class RenderAccept extends Render {

    protected Map&lt;String, Object&gt; model;

    public RenderAccept(Map&lt;String, Object&gt; model) {
        this.model = model;
    }

    public Map&lt;String, Object&gt; getModel() {
        return model;
    }

   @Override
   public void create(Mapping mapping, Call call) throws IOException, ServletException {
        // Get accept in header
        HttpContext context = call.getContext();
        HttpServletRequest request = context.getRequest();
        String accept = request.getHeader("Accept");

        Render render = null;
        if (accept.equals("application/json")) {
            // Delegate to renderJSON
            render = new RenderJson(model);

        } else if (accept.equals("text/xml")) {
            // Delegate to renderXML
            render = new RenderXml(model);

        } else {
            throw new IllegalArgumentException("Invalid accept");
        }

        // Create the real render
        render.create(mapping, call);
    }
}
</pre>

<h2 class="page-header" id="websocket">WebSocket</h2>
<p>
    WebSocket est un protocole de communication entre le client et le serveur. Il permet 
    une connexion permanente pour réaliser du push/pull (communication bidirectionnelle). Pour établir la connexion le client 
    envoi une requête en <code>GET</code> avec des headers spécifiques.
</p>

<p>
    Pré-requis :
</p>
<ul>
    <li>pour Tomcat : il faut une version suppérieure à la version 7.0.29</li>
    <li>pour Jetty : il faut la dépendance vers jetty-websocket</li>
    <li>
        pour GlassFish : il faut activer le support par la commande suivante 
        <code>asadmin set configs.config.server-config.network-config.protocols.protocol.http-listener-1.http.websockets-support-enabled=true</code>
    </li>
</ul>

<p>
    Pour intercepter l'appel en WebSocket, il suffit dans WebMotion de rajouter 
    une régle de mapping sur la méthode <code>GET</code>.
</p>
<p>
    <span class="label label-info">Exemple</span> Interception d'une requête WebSocket :
</p>
<pre>
GET           /echo/ws                    Echo.createSocket
</pre>

<p>
    La méthode doit retourner un render de type WebSocket. Il existe une
    implantation simple pour envoyer et recevoir les messages dans votre WebSocket.
</p>
<pre class="prettyprint">
public class Echo extends WebMotionController {

    public Render createSocket() {
        WebMotionWebSocket socket = new EchoWebSocket();
        return new RenderWebSocket(socket);
    }

    public class EchoWebSocket extends WebMotionWebSocket {

        @Override
        public void receiveTextMessage(String message) {
            socket.sendTextMessage(message);
        }
    }
}
</pre>

<p>
    Il existe aussi une implantation avec le support de message en JSON. 
    Il faut envoyer un message avec un objet JSON avec le nom de la méthode et 
    les paramètres pour éxécuter une méthode dans la WebSocket. 
</p>
<p>
    Après l'exécution de la méthode, un message avec un objet JSON est retourné 
    qui contient le nom de la méthode exécutée et le retour de la méthode.
</p>
<p>
    <span class="label label-info">Exemple</span> Création d'un message en JavaScript :
</p>
<pre class="prettyprint">
var connection = new WebSocket(url);

connection.onopen = function () {
    var event = {
        method : "echo",
        params : {
            value : "test"
        }
    }
    connection.send(JSON.stringify(event));
};

connection.onmessage = function (e) {
    var message = JSON.parse(e.data);
    console.log(message.method);
    console.log(message.result);
};
</pre>

<p>
    Avec comme WebSocket :
</p>
<pre class="prettyprint">
public class EchoWebSocket extends WebMotionWebSocketJson {
    public String echo(String value) {
        return value;
    }
}
</pre>

<p>
    Pour retenir des paramètres communs entre les WebSockets, il est possible d'utiliser 
    le contexte du serveur. Par exemple il est possible de broadcaster l'ensemble des 
    WebSockets :
</p>
<pre class="prettyprint">
public class EchoWebSocket extends WebMotionWebSocket {

    @Override
    public void onOpen() {
        // Store all connections
        ServerContext serverContext = getServerContext();
        List&lt;WebMotionWebSocket&gt; connections = (List&lt;WebMotionWebSocket&gt;) serverContext.getAttribute("connections");
        if (connections == null) {
            connections = new ArrayList&lt;WebMotionWebSocket>();
            serverContext.setAttribute("connections", connections);
        }
        connections.add(this);
    }

    @Override
    public void receiveTextMessage(String message) {
        // Broadcast the message
        ServerContext serverContext = getServerContext();
        List&lt;WebMotionWebSocket&gt; connections = (List&lt;WebMotionWebSocket&gt;) serverContext.getAttribute("connections");
        for (WebMotionWebSocket socket : connections) {
            socket.sendTextMessage(message);
        }
    }
}
</pre>

<p>
    Il est bien sûr possible de paramètrer votre méthode et donc votre WebSocket.
</p>
<pre class="prettyprint">
public class Echo extends WebMotionController {

    public Render createSocket(String who) {
        WebMotionWebSocket socket = new EchoWebSocket(who);
        return new RenderWebSocket(socket);
    }

    public class EchoWebSocket extends WebMotionWebSocket {

        protected String who;

        public EchoWebSocket(String who) {
            this.who = who;
        }

        @Override
        public void receiveTextMessage(String message) {
            socket.sendTextMessage(who + " = " + message);
        }
    }
}
</pre>

<h2 class="page-header" id="context">Contexte web</h2>
<p>
    Tous les contrôleurs de l'application ont accès au contexte web de l'application,
    soit par le biais de la méthode <code>getContext</code> soit directement en paramètre de la méthode. 
    Le context web donne accès à l'ensemble des informations sur la requête et la réponse comme les 
    messages flash, la gestion des cookies, la session cliente, ...
</p>

<p>
    <span class="label label-info">Exemple</span> Recupération du contexte par paramètre :
</p>
<pre class="prettyprint">
public class Action extends WebMotionController {
    public Render run(HttpContext context) {
        ...
        return ...
    }
    ...
}
</pre>

<p>
    <span class="label label-info">Exemple</span> Recupération du contexte par méthode :
</p>
<pre class="prettyprint">
public class Action extends WebMotionController {
    public Render run() {
        HttpContext context = getContext();
        ...
        return ...
    }
    ...
}
</pre>

<p>
    Il est possible d'accéder à un certains nombre de données directement en paramètre des méthodes.
    Dès lors qu'un paramètre de l'un des types suivants apparaît dans la liste des paramètres d'une méthode
    d'un contrôleur, l'instance sera automatiquement définie par WebMotion. Il est à noter que seule la présence
    du type provoque la définition dynamique de l'objet, le nom du paramètre n'influe pas. 
</p>
<ul>
    <li><strong>HttpContext : </strong>contexte web de l'application</li>
    <li><strong>HttpSession : </strong>session utilisateur</li>
    <li><strong>HttpServletRequest</strong> ou <strong>ServletRequest</strong> : requête appelant le serveur</li>
    <li><strong>HttpServletResponse</strong> ou <strong>ServletResponse</strong> : réponse retournée au client</li>
    <li><strong>ServletContext : </strong> contexte de la servlet</li>
    <li><strong>ServerContext : </strong> contexte du serveur</li>
    <li><strong>ErrorData : </strong>en cas d'erreur, des informations complémentaires</li>
    <li><strong>Exception : </strong>en cas d'erreur, l'exception responsable de l'erreur</li>
    <li><strong>FileProgressListener : </strong>permet de suivre la progression de chargement de fichier</li>
    <li><strong>Mapping : </strong>l'instance applicative du mapping</li>
    <li><strong>Config : </strong>la configuration de WebMotion</li>
    <li><strong>Properties : </strong>la configuration de l'application</li>
    <li><strong>Call : </strong>le contexte d'appel des actions</li>
    <li><strong>CookieManager : </strong>le gestionnaire des cookies</li>
    <li><strong>ClientSession : </strong>la session cliente</li>
</ul>

<p>
    <span class="label label-info">Exemple</span> Recupération de la session :
</p>
<pre class="prettyprint">
public class Action extends WebMotionController {
    public Render run(HttpSession session) {
        ...
        return ...
    }
    ...
}
</pre>

<p>
    <span class="label label-info">Exemple</span> Recupération d'une exception :
</p>
<pre class="prettyprint">
public class Error extends WebMotionController {
    public Render display(TechnicalException exception) {
        ...
        return ...
    }
    ...
}
</pre>

<h3 id="properties">Configuration de l'application</h3>
<p>
    WebMotion permet de gérer simplement dans le fichier de mapping une configuration 
    pour votre application. Pour plus de renseignements, veuillez vous reporter 
    à la section <a href="mapping#properties">Mapping - Configuration de l'application</a>.
    La configuration repose sur la bibliothèque <a href="http://commons.apache.org/configuration">Apache Commons Configuration</a>.
</p>

<p>
    <span class="label label-info">Exemple</span> Recupération de la configuration dans une action :
</p>
<pre class="prettyprint">
public Render run(Properties configuration) {
    ...
}
</pre>
    
<p>
    <span class="label label-info">Exemple</span> Recupération de la configuration dans le listener :
</p>
<pre class="prettyprint">
public class Listener implements WebMotionServerListener {

    @Override
    public void onStart(Mapping mapping, ServerContext context) {
        Mapping rootMapping = context.getMapping();
        Properties configuration = rootMapping.getProperties();
        ...
    }

    @Override
    public void onStop(ServerContext context) {
        // Do nothing
    }
}
</pre>
    
<p>
    L'objet <code>Properties</code> permet de récupérer les valeurs selon différents types.
</p>
<p>
    <span class="label label-info">Exemple</span> Recupération d'un String :
</p>
<pre class="prettyprint">
String value = configuration.getString("key");
</pre>
<p>
    Avec comme mapping :
</p>
<pre class="prettyprint">
[config.properties]
key=test
</pre>

<p>
    <span class="label label-info">Exemple</span> Recupération d'un tableau de String :
</p>
<pre class="prettyprint">
String[] values = configuration.getStringArray("key");
</pre>
<p>
    Avec comme mapping :
</p>
<pre class="prettyprint">
[config.properties]
key=test1,test2,test3
</pre>

<h3 id="flashmessage">Messages flash</h3>
<p>
    L'une des difficultés lors d'une redirection HTTP est de compléter la réponse pour informer l'utilisateur d'une information temporaire. 
    Les messages flash ont ce but, et sont disponibles dans le contexte HTTP. Les messages flash peuvent être de différents types : info, error, warning et misc.
    Ils sont récupérables dans la requête par l'attibut <code>flashMessages</code>.
</p>

<p>
    <span class="label label-info">Exemple</span> Message d'info :
</p>
<pre class="prettyprint">
public Render send() {
    HttpContext context = getContext();
    context.addInfoMessage("my_message", "test");
    return renderURL("/url");
}
</pre>

<p>Avec comme récupération dans la request du message en JSP :</p>
<pre class="prettyprint">
${flashMessages.infos.my_message}
</pre>

<p>
    <span class="label label-info">Exemple</span> Message d'erreur :
</p>
<pre class="prettyprint">
public Render send() {
    HttpContext context = getContext();
    context.addErrorMessage("my_message", "test");

    return renderURL("/url");
}
</pre>

<p>Avec comme récupération dans la request du message en JSP :</p>
<pre class="prettyprint">
${flashMessages.errors.my_message}
</pre>

<p>
    <span class="label label-info">Exemple</span> Message d'avertissement :
</p>
<pre class="prettyprint">
public Render send() {
    HttpContext context = getContext();
    context.addWarningMessage("my_message", "test");
    return renderURL("/url");
}
</pre>

<p>Avec comme récupération dans la request du message en JSP :</p>
<pre class="prettyprint">
${flashMessages.warnings.my_message}
</pre>

<p>
    <span class="label label-info">Exemple</span> Message divers :
</p>
<pre class="prettyprint">
public Render send() {
    HttpContext context = getContext();
    context.addMessage("my_message", "test");
    return renderURL("/url");
}
</pre>

<p>Avec comme récupération dans la request du message en JSP :</p>
<pre class="prettyprint">
${flashMessages.miscs.my_message}
</pre>

<p>
    <span class="label label-info">Exemple</span> Récupération de l'ensemble des messages en JSP :
</p>
<pre class="prettyprint">
${flashMessages.messages}
</pre>

<h3 id="cookie">Gestion des cookies</h3>
<p>
    Le framework propose un gestionnaire de cookie pour simplifier l'utilisation des cookies,
    en proposant des fonctionnalités comme la récupération d'un cookie par son nom,
    la suppression d'un cookie, la sécurisation, la manipulation d'objet comme valeur de cookie, etc.
</p>

<p>
    <span class="label label-info">Exemple</span> Création d'un nouveau cookie :
</p>
<pre class="prettyprint">
CookieManager manager = context.getCookieManager();
CookieEntity cookie = manager.create("name", "value");
cookie.setPath("/index.html");
manager.add(cookie);
</pre>

<p>
    <span class="label label-info">Exemple</span> Récupération d'une valeur :
</p>
<pre class="prettyprint">
CookieManager manager = context.getCookieManager();
CookieEntity cookie = manager.get("name");
String value = cookie.getValue();
</pre>

<p>
    <span class="label label-info">Exemple</span> Suppression d'un cookie :
</p>
<pre class="prettyprint">
CookieManager manager = context.getCookieManager();
manager.remove("name");
</pre>

<p>
    <span class="label label-info">Exemple</span> Enregistrement d'un objet comme valeur :
</p>
<pre class="prettyprint">
CookieManager manager = context.getCookieManager();
CookieEntity cookie = manager.create("name", new User("John"));
manager.add(cookie);
</pre>

<p>
    <span class="label label-info">Exemple</span> Récupération d'un objet comme valeur :
</p>
<pre class="prettyprint">
CookieEntity cookie = manager.get("name");
User user = cookie.getValue(User.class);
</pre>

<p>
    Il est possible de gérer des cookies sécurisés, cette sécurité permet de garantir :
</p>
<ul>
    <li>la confidentialité des données, en utilisant l'algorithme symétrique de chiffrement Rijndael</li>
    <li>l'intégrité des données, en créant un hash des données</li>
    <li>une protection contre les replay attacks, en intégrant l'identifiant Apache de session SSL</li>
    <li>une protection contre les volume attacks, en intégrant le nom de l'utilisateur</li>
</ul>
<p>
    Une clé secrète est utilisée pour garantir la sécurité des cookies. Elle est 
    auto-générée si elle n'est pas définie dans le fichier de mapping. 
    Pour plus de renseignements, veuillez vous reporter à la section 
    <a href="mapping#config">Mapping - Config</a>.
</p>

<p>
    <span class="label label-info">Exemple</span> Récupération d'un gestionnaire de cookie complètement sécurisé :
</p>
<pre class="prettyprint">
CookieManager manager = context.getCookieManager("username", true, true);
</pre>

<p>
    Par la suite, le gestionnaire de cookies sécurisés s'utilise de façon transparente. 
    Il n'est pas récupérable par l'injection au niveau des paramètres, car le gestionnaire 
    propose plusieurs niveaux de sécurité (cryptographie et/ou SSL).
</p>

<h3 id="session">Session cliente</h3>
<p>
    La session cliente est une session stockée sous forme de cookies sécurisés sur le navigateur 
    du client, ce qui permet une grande souplesse pour la scabilité de vos serveurs. Elle
    s'utilise comme une session classique. La session est créée et sauvegardée au 
    moment de son utilisation.
</p>

<p>
    <span class="label label-info">Exemple</span> Récupération de la session cliente :
</p>
<pre class="prettyprint">
public Render action(ClientSession session) {
    ...
}
</pre>

<p>
    La fonctionnalité supplémentaire porte sur la récupération des attributs qui peut se 
    faire selon un type de donnée, ce qui évite un cast.
</p>

<p>
    <span class="label label-info">Exemple</span> Utilisation de la session cliente :
</p>
<pre class="prettyprint">
session.setAttribute("name", "value");
String value = session.getAttribute("name", String.class);
</pre>

<p>
    Par défaut, la durée de validité de la session est fixée classiquement à 2 heures. Vous pouvez 
    changer la valeur par le biais de la méthode <code>setMaxInactiveInterval</code> :
</p>

<pre class="prettyprint">
session.setMaxInactiveInterval(30 * 60); // 30 min
</pre>

<p>
    La session cliente comporte quelques limitations dù au système de stockage des cookies, 
    comme la taille maximum de 4ko d'un cookie. De plus, une clé secrète est utilisée pour 
    garantir la sécurité de la session. Elle est auto-générée si elle n'est pas définie 
    dans le fichier de mapping. Pour plus de renseignements, veuillez vous reporter 
    à la section <a href="mapping#config">Mapping - Config</a>.
</p>

<h2 class="page-header" id="validation">Validation des paramètres des contrôleurs</h2>
<p>
    WebMotion propose une validation des paramètres des actions Java, sur la JSR 303.
    Pour plus de renseignements sur la JSR, vous pouvez consulter le site <a href="http://jcp.org/">jcp</a>.
    Un bean ne sera validé uniquement si les annotations <code>@Valid</code> ou <code>@ValidGroup</code>
    apparaissent sur le paramètre correspondant dans la méthode appellée.
    Il faut noter que <code>@ValidGroup</code> est la seule annotation 
    propre au framework qui permet la validation du bean sur un groupe.
    Il est possible de créer ses propres annotations de validation et les utiliser avec WebMotion.
</p>

<p>
    <span class="label label-info">Exemple</span> Validation simple :
</p>
<pre class="prettyprint">
public Render search(@NotNull String query) {
    // ...
}
</pre>

<p>
    <span class="label label-info">Exemple</span> Validation sur un bean, attention il peut être null :
</p>
<pre class="prettyprint">
public Render create(@Valid Book book) {
    // ...
}
</pre>

<p>
    <span class="label label-info">Exemple</span> Validation sur un bean, en précisant qu'il ne peut être null :
</p>
<pre class="prettyprint">
public Render create(@Valid @NotNull Book book) {
    // ...
}
</pre>

<p>
    <span class="label label-info">Exemple</span> Validation d'un groupe sur un bean  :
</p>
<pre class="prettyprint">
public Render comment(@ValidGroup(MyGroup.class) Book book) {
    // ...
}
</pre>

<div class="alert alert-warning">
    <p>
        <span class="label label-warning">Attention</span>&nbsp; GlassFish supporte la validation sur les méthodes qu'à partir de la version 3.1.2.
</div>

<h2 class="page-header" id="file">Chargement de fichiers</h2>
<p>
    Les fichiers sont gérés comme des paramètres simples. WebMotion s'occupe avec l'aide
    de <a href="http://commons.apache.org/fileupload/">FileUpload</a> de faire le traitement 
    pour la récupération multi-part. Il est possible d'utiliser, comme type de paramètre, soit la classe File, 
    soit le wrapper proposer par WebMotion pour récupérer des informations complémentaires sur le fichier, à savoir
    son nom, sa taille et son type mime.
</p>

<p>
    <span class="label label-info">Exemple</span> Récupération simple du fichier  :
</p>
<pre class="prettyprint">
public Render upload(File file) {
    // ...
}
</pre>

<p>
    <span class="label label-info">Exemple</span> Récupération par le wrapper  :
</p>
<pre class="prettyprint">
public Render upload(UploadFile file) {
    String name = file.getName();
    // ...
}
</pre>

<p>
    Il est possible de suivre l'évolution du téléchargement par le biais d'un 
    écouteur mis à disposition dans la session de l'utilisateur.
</p>

<p>
    <span class="label label-info">Exemple</span> Récupération des informations de progression en format JSON  :
</p>
<pre class="prettyprint">
public Render progress(FileProgressListener listener) {
    return renderJSON(listener);
}
</pre>

<h2 class="page-header" id="tu">Tests unitaires</h2>
<p>
    Vous pouvez effectuer des tests unitaires pour vérifier le bon fonctionnement 
    de vos actions. Pour cela il faut rajouter la dépendance suivantes en scope 
    <code>test</code> dans votre projet :
</p>

<pre class="prettyprint">
&lt;dependency&gt;
    &lt;groupId&gt;org.debux.webmotion&lt;/groupId&gt;
    &lt;artifactId&gt;webmotion-unittest&lt;/artifactId&gt;
    &lt;version&gt;2.4&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</pre>

<p>
    Pour faire fonctionner les tests, WebMotion utilise le serveur d'application <a href="http://www.eclipse.org/jetty/">Jetty</a>. 
    Le serveur est démarré au début des tests. Les tests unitaires sont compatible 
    <a href="http://junit.org/">JUnit</a> et <a href="http://testng.org">TestNG</a>.
</p>

<h3 id="junit">JUnit</h3>
<p>
    Pour écrire les tests en <a href="http://junit.org/">JUnit</a>, il vous faut ajouter la dépendance sur la libraire JUnit.
</p>
<pre class="prettyprint">
&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.11&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</pre>

<p>
    Ensuite il faut hériter de la classe WebMotionJUnit :
</p>
<pre class="prettyprint">
@RunWith(JUnit4.class)
public class Example extends WebMotionJUnit {
    
    @Test
    public void testRequest() {
        // write the test
    }
    
}
</pre>

<h3 id="testng">TestNG</h3>
<p>
    Pour écrire les tests en <a href="http://testng.org">TestNG</a>, il vous faut ajouter la dépendance sur la libraire TestNG.
</p>
<pre class="prettyprint">
&lt;dependency&gt;
    &lt;groupId&gt;org.testng&lt;/groupId&gt;
    &lt;artifactId&gt;testng&lt;/artifactId&gt;
    &lt;version&gt;6.8&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</pre>

<p>
    Ensuite il faut hériter de la classe WebMotionTestNG :
</p>
<pre class="prettyprint">
public class Example extends WebMotionTestNG {

    @Test
    public void testRequest() {
        // write the test
    }
    
}
</pre>

<h3 id="hc">Apache HttpComponents</h3>
<p>
    Pour écrire le contenu du test, vous pouvez utiliser un client HTTP au choix.
    WebMotion préconise l'utilisation <a href="http://hc.apache.org/">HttpComponents</a> d'Apache.
    WebMotion vous guide dans l'utilisation de la librairie d'Apache en vous proposant des 
    utilitaires pour la création de l'url et la création de la requête. 
</p>
<p>
    <span class="label label-info">Exemple</span> Exemple de création d'une requête GET :
</p>
<pre class="prettyprint">
String result = createRequest("/index")
        .addParameter("query", "test")
        .Get()
        .execute()
        .returnContent().asString();
</pre>

<p>
    <span class="label label-info">Exemple</span> Exemple de création d'une requête POST :
</p>
<pre class="prettyprint">
String result = createRequest("/index")
        .Post()
        .bodyForm(
            Form.form()
                .add("username", "vip")
                .add("password", "secret")
                .build()
        )
        .execute()
        .returnContent().asString();
</pre>

<h3 id="config">Configuration</h3>
<p>
    Vous pouvez configurer différents éléments en redéfinnissant les méthodes de 
    la classe abstraite. Attention vous ne pouvez pas avoir des configurations 
    différentes dans le même jeu de tests.
</p>
<p>
    <span class="label label-info">Exemple</span> Exemple de changement du port :
</p>
<pre class="prettyprint">
@Override
protected int getPort() {
    return 8080;
}
</pre>

<div class="well" style="text-align: center;">
    <a class="btn large" style="float:left;" href="documentation">« Documentation</a>
    <a class="btn large" style="margin: 0 auto;" href="#">Haut de page</a>
    <a class="btn primary large" style="float:right;" href="extensions">Extensions »</a>
</div>

</div>
